import random


def sample(population, k):
    """
    Chooses k unique random elements from a population bag.

    Returns a new bag containing elements from the population while
    leaving the original population unchanged.

    Parameters
    ----------
    population : Bag
        Elements to sample.
    k : integer, optional
        Number of elements to sample.
    Examples
    --------
    >>> import dask.bag as db
    >>> from dask.bag import random
    >>>
    >>> b = db.from_sequence(range(5), npartitions=2)
    >>> len(list(random.sample(b, 3).compute()))
    3
    """
    return _sample(population, k, False)


def choices(population, k=1):
    """
    Return a k sized list of population elements chosen with replacement.

    If the relative weights or cumulative weights are not specified,
    the selections are made with equal probability.

    Parameters
    ----------
    population : Bag
        Elements to sample.
    k : integer, optional
        Number of elements to sample.
    Examples
    --------
    >>> import dask.bag as db
    >>> from dask.bag import random
    >>>
    >>> b = db.from_sequence(range(5), npartitions=2)
    >>> len(list(random.choices(b, 3).compute()))
    3
    """
    return _sample(population, k, True)


def _sample(population, k=1, replace=False):
    return population.map_partitions(_sample_map_partitions, k, replace).reduction(
        lambda x: x, _sample_reduce
    )


def _sample_map_partitions(population, k=1, replace=True):
    """
    Map function used on the sample and choices functions.
    Parameters
    ----------
    population : list
        List of elements to sample.
    k : int, optional
        Number of elements to sample. Default is 1.
    replace : boolean, optional
        Whether the sample is with or without replacement

    Returns a tuple, composed by:
    - list of k samples;
    - total number of elements from where the sample was drawn;
    - total number of elements to be sampled;
    - boolean which is True whether the sample is with or without replacement.
    """
    lx = len(population)
    real_k = k if k <= lx else lx
    sample_fun = random.choices if replace else random.sample
    # because otherwise it raises IndexError:
    sampled = [] if real_k == 0 else sample_fun(population, k=real_k)
    return sampled, lx, k, replace


def _sample_reduce(reduce_iter):
    """
    Reduce function used on the sample and choice functions.

    Parameters
    ----------
    reduce_iter : iterable
        Each element is a tuple coming generated by the _sample_map_partitions function.

    Returns a sequence of uniformly distributed samples;
    """
    ns_ks = []
    s = []
    n = 0
    k = 0
    tot_ks = 0
    replace = True
    # unfolding reduce outputs
    for i in reduce_iter:
        (s_i, n_i, k, replace) = i
        s.extend(s_i)
        n += n_i
        k_i = len(s_i)
        tot_ks += k_i
        ns_ks.append((n_i, k_i))

    if k < 0 or ((k > n) and not replace):
        raise ValueError("Sample larger than population or is negative")

    # creating the probability array
    p = []
    for n_i, k_i in ns_ks:
        if k_i > 0:
            p_i = n_i / (k_i * n)
            p += [p_i] * k_i

    final_k = min(k, tot_ks) if not replace else k
    return random.choices(population=s, weights=p, k=final_k)
