import heapq
import math
import random
from functools import partial


def sample(population, k):
    return _sample(population=population, k=k, replace=False)


def choices(population, k=1):
    return _sample(population=population, k=k, replace=True)


def _sample(population, k, replace=False):
    return population.reduction(
        partial(_sample_map_partitions, k=k, replace=replace),
        partial(_sample_reduce, k=k, replace=replace),
    )


def _sample_map_partitions(population, k, replace):
    """
    Map function used on the sample and choices functions.
    Parameters
    ----------
    population : list
        List of elements to sample.
    k : int, optional
        Number of elements to sample. Default is 1.

    Returns
    -------
    sample : list
        List of sampled elements from the partition.
    lx : int
        Number of elements on the partition.
    k : int
        Number of elements to sample.
    """
    lx = len(population)
    real_k = k if k <= lx else lx
    sample_func = random.choices if replace else random.sample
    # because otherwise it raises IndexError:
    sampled = [] if real_k == 0 else sample_func(population=population, k=real_k)
    return sampled, lx


def _sample_reduce(reduce_iter, k, replace):
    """
    Reduce function used on the sample and choice functions.

    Parameters
    ----------
    reduce_iter : iterable
        Each element is a tuple coming generated by the _sample_map_partitions function.

    Returns a sequence of uniformly distributed samples;
    """
    ns_ks = []
    s = []
    n = 0
    # unfolding reduce outputs
    for i in reduce_iter:
        (s_i, n_i) = i
        s.extend(s_i)
        n += n_i
        k_i = len(s_i)
        ns_ks.append((n_i, k_i))

    if k < 0 or (k > n and not replace):
        raise ValueError("Sample larger than population or is negative")

    # creating the probability array
    p = []
    for n_i, k_i in ns_ks:
        if k_i > 0:
            p_i = n_i / (k_i * n)
            p += [p_i] * k_i

    sample_func = random.choices if replace else _weighted_sampling_without_replacement
    return sample_func(population=s, weights=p, k=k)


def _weighted_sampling_without_replacement(population, weights, k):
    """
    Source:
        Weighted random sampling with a reservoir, Pavlos S. Efraimidis, Paul G. Spirakis
    """
    elt = [(math.log(random.random()) / weights[i], i) for i in range(len(weights))]
    return [population[x[1]] for x in heapq.nlargest(k, elt)]
